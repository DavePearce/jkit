// This file is part of the Java Compiler Kit (JKit)
//
// The Java Compiler Kit is free software; you can
// redistribute it and/or modify it under the terms of the
// GNU General Public License as published by the Free Software
// Foundation; either version 2 of the License, or (at your
// option) any later version.
//
// The Java Compiler Kit is distributed in the hope
// that it will be useful, but WITHOUT ANY WARRANTY; without
// even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE.  See the GNU General Public License
// for more details.
//
// You should have received a copy of the GNU General Public
// License along with the Java Compiler Kit; if not,
// write to the Free Software Foundation, Inc., 59 Temple Place,
// Suite 330, Boston, MA  02111-1307  USA
//
// (C) David James Pearce, 2009.

package jkit.error;

import java.io.File;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Stack;

import jkit.compiler.ClassLoader;
import jkit.compiler.SyntaxError;
import jkit.java.stages.TypeSystem;
import jkit.java.tree.Expr;
import jkit.java.tree.Stmt;
import jkit.jil.tree.SourceLocation;
import jkit.jil.tree.Type;
import jkit.jil.util.Types;
import jkit.util.Pair;
import jkit.compiler.Clazz;

/**
 * This class contains a collection of helper methods to increase
 * the usefulness of JKit's error messages by offering suggestions for
 * substitute code.
 *
 * @author Daniel Campbell
 *
 */
public class ErrorHandler {

	//The maximum difference between a target and a candidate to be considered for substitution
	public final static int MAX_DIFFERENCE = 3;

	/**
	 * Handles errors where an operator was used in an expression where the lhs or rhs
	 * were not valid types for the operator. Uses the same code as for the more general type
	 * mismatch exceptions to generate suggestions, but the error message contains more context information.
	 *
	 * @param ex	- The exception being handled
	 * @param loc	- The location of the exception in the source code
	 */
	public static void handleOperatorTypeMismatch(OperatorTypeMismatchException e,
			SourceLocation loc) {

		Expr found = e.found();
		Type foundType = found.attribute(Type.class);
		Type expected = e.expected();
		ClassLoader loader = e.loader();

		List<Pair<String, Integer>> suggestions = findTypeSuggestions(found, expected, loader);

		String suggestion = (suggestions.isEmpty()) ? "" : suggestions.get(0).first();

		String msg = String.format("Syntax Error: Type %s invalid for operator %s, %s required.%s",
				foundType, e.operator(), e.allowed(), suggestion);

		SyntaxError.syntax_error(msg, loc);
	}

	/**
	 * This method handles the broad case where JKit was expecting one type and found another.
	 * It analyzes the types found and expected, and then employs a mix of heuristics (such
	 * as the fact that if there's an assignment where a boolean is expected == could be used)
	 * and suggestions to improve the error message given.
	 *
	 * @param e - The TypeMismatchException containing the necessary data
	 * @param loc - The location of the error
	 */
	public static void handleTypeMismatch(TypeMismatchException e, SourceLocation loc) {
		Expr found = e.found();
		Type foundType = found.attribute(Type.class);
		Type expected = e.expected();
		ClassLoader loader = e.loader();

		List<Pair<String, Integer>> suggestions = findTypeSuggestions(found, expected, loader);

		String msg = String.format("Syntax Error: Expected %s, found %s%s", expected, foundType,
				(suggestions.isEmpty()) ? "" : suggestions.get(0).first());

		SyntaxError.syntax_error(msg, loc);
	}

	/**
	 * Helper method - generates a list of possible solution suggestions to the
	 * user to solve a compile error generated by an expression type not matching
	 * the expected type
	 *
	 * @param found		- The found expression
	 * @param expected	- The expected expression type
	 * @param loader	- The classloader
	 * @return
	 */
	private static List<Pair<String, Integer>> findTypeSuggestions(
			Expr found, Type expected, ClassLoader loader) {

		List<Pair<String, Integer>> suggestions = new ArrayList<Pair<String, Integer>>();

		//Check for = instead of ==
		checkForAssignmentInComparison(found, expected, suggestions);

		//Check for possible primitive type explicit casting
		checkForExplicitCast(found, expected, suggestions);

		//Check if the boxed type has a method that fits
		checkForBoxedMethods(found, expected, suggestions, loader);

		//Check for alternate fields if found was a field dereference
		if (found instanceof Expr.Deref)
			checkForAltFields((Expr.Deref)found, expected, suggestions, loader);

		//Look for alternative methods if found was a method invocation
		else if (found instanceof Expr.Invoke)
			checkForAltMethods((Expr.Invoke)found, expected, suggestions, loader);


		//A general catch all - check if the expression is attached to a class we can comb through
		//Only use this if expression wasn't a field or invoke
		else if (found.attribute(Type.Clazz.class) != null) {

			try {
				Clazz foundClass = loader.loadClass(found.attribute(Type.Clazz.class));
				checkClassForSuggestions(foundClass, found, expected, suggestions, loader);

			}
			catch(ClassNotFoundException e) {
				//Should never happen, if it does we just skip this step
			}
		}
		Collections.sort(suggestions, new WeightComparator<Pair<String, Integer>>());
		return suggestions;
	}

	/**
	 * Helper method - checks if we could suggest using '==' instead of '='
	 * to the user
	 *
	 * @param found			- The expression found (invalid type)
	 * @param expected		- The expected expression type
	 * @param suggestions	- The list of suggestions so far
	 */
	private static void checkForAssignmentInComparison(Expr found,
			Type expected, List<Pair<String, Integer>> suggestions) {

		if (expected instanceof Type.Bool) {
			//Special case for = instead of ==
			if (found instanceof Stmt.Assignment) {
				Stmt.Assignment assign = (Stmt.Assignment) found;
				suggestions.add(new Pair<String, Integer>
					(String.format("\nA possible substitute is %s == %s", assign.lhs(), assign.rhs()), 0));
			}
		}
	}

	/**
	 * Helper method - checks if we could suggest an explicit cast
	 * between primitive types to the user
	 *
	 * @param found		 	- The found (invalid) expression
	 * @param expected	 	- The expected expression type
	 * @param suggestions	- The list of suggestions so far
	 */
	private static void checkForExplicitCast(Expr found,
			Type expected, List<Pair<String, Integer>> suggestions) {

		Type foundType = found.attribute(Type.class);

		if (expected instanceof Type.Primitive &&
				foundType instanceof Type.Primitive) {
			String suggestion = "";
			if (!(expected instanceof Type.Bool) && ! (found instanceof Type.Bool)) {
				suggestion = String.format("\nExplicit cast possible: (%s) (%s)", expected, found);
				suggestions.add(new Pair<String, Integer>(suggestion, 0));
			}
		}
	}

	/**
	 * Helper method - checks if we can suggest a method belonging to
	 * the boxed type of the found expression to the user
	 *
	 * @param found			- The found expression
	 * @param expected		- The expected expression type
	 * @param suggestions	- The list of suggestions so far
	 * @param loader		- The classloader
	 */
	private static void checkForBoxedMethods(Expr found, Type expected,
			List<Pair<String, Integer>> suggestions, ClassLoader loader) {

		Type foundType = found.attribute(Type.class);

		if (foundType instanceof Type.Primitive) {
			try {
				Clazz boxed = loader.loadClass(Types.boxedType((Type.Primitive)foundType));
				for (Clazz.Method m : boxed.methods()) {
					if (m.type().returnType() instanceof Type.Void || !m.type().returnType().equals(expected))
						continue;

					int weight = (m.isVariableArity()) ? m.parameters().size()-1 : m.parameters().size();
					String suggestion = String.format("\nA possible substitute is: ((%s)(%s)).%s(",
							Types.boxedType((Type.Primitive) foundType), found, m.name());

					//Formatting must be double-checked for variable arity methods
					for (int i = 0; i < m.type().parameterTypes().size(); i++) {
						if (i != 0)
							suggestion += (", ");

						Type t = m.type().parameterTypes().get(i);
						suggestion += (m.isVariableArity() && i == m.type().parameterTypes().size()-1) ?
								((Type.Array)t).element().toString() : t.toString();
					}

					if (m.isVariableArity())
						suggestion += "...";
					suggestion += ")";
					suggestions.add(new Pair<String, Integer>(suggestion, weight));
				}
			}
			catch (ClassNotFoundException e) {
				//Should never happen. We just skip this step if it does
			}
		}
	}

	/**
	 * Helper method - given a field dereference of the wrong type, check for alternate
	 * fields of the correct type, and construct an appropriate suggestion for the user
	 *
	 * @param deref			- The field dereference
	 * @param expected		- The expected field type
	 * @param suggestions	- The list of suggestions so far
	 * @param loader		- The classloader
	 */
	private static void checkForAltFields(Expr.Deref deref, Type expected,
			List<Pair<String, Integer>> suggestions, ClassLoader loader) {

		String field = deref.name();

		//If owner is null, something is very wrong
		Type.Reference owner = deref.target().attribute(Type.Reference.class);
		Set<Clazz> classes = getClasses(loader, owner);
		classes = getSuperClasses(loader, classes);

		Pair<List<Pair<Clazz.Field, Integer>>,
		     List<Pair<Clazz.Method, Integer>>> subs = findFieldSuggestions(classes, field, expected, loader);

		List<Pair<Clazz.Field, Integer>> fields = subs.first();
		List<Pair<Clazz.Method, Integer>> methods = subs.second();

		String suggestion;

		if (fields.isEmpty()) {
			if (methods.isEmpty()) {
				suggestion = "";
			}
			else suggestion = String.format("\nA possible substitute is method %s.%s()", ClassLoader.pathChild(owner.toString()),
					methods.get(0).first().name());
		}

		else if (methods.isEmpty()) {
			suggestion = String.format("\nA possible substitute is field %s.%s", ClassLoader.pathChild(owner.toString()),
					fields.get(0).first().name());
		}

		else {

			suggestion = (fields.get(0).second() > methods.get(0).second()) ?
					String.format("\nA possible substitute is method %s.%s()", ClassLoader.pathChild(owner.toString()),
							methods.get(0).first().name()) :
					String.format("\nA possible substitute is field %s.%s", ClassLoader.pathChild(owner.toString()),
									fields.get(0).first().name());
		}

		int weight = (fields.get(0).second() > methods.get(0).second()) ?
				methods.get(0).second() : fields.get(0).second();

		suggestions.add(new Pair<String, Integer>(suggestion, weight));
	}

	/**
	 * Helper method that, given a method invocation that returned a bad type,
	 * checks for alternate methods of the correct type it can suggest to the
	 * user.
	 *
	 * @param inv			- The method invocation found
	 * @param expected		- The expected method return type
	 * @param suggestions	- The list of suggestions so far
	 * @param loader		- The classloader
	 */
	private static void checkForAltMethods(Expr.Invoke inv, Type expected,
			List<Pair<String, Integer>> suggestions, ClassLoader loader) {

		Type.Reference owner = inv.target().attribute(Type.Reference.class);
		Set<Clazz> classes = getClasses(loader, owner);
		classes = getSuperClasses(loader, classes);

		List<Type> params = new ArrayList<Type>();

		//Must convert from java type to jil type
		for (jkit.java.tree.Type t : inv.typeParameters())
			params.add(t.attribute(Type.class));

		List<Pair<Clazz.Method, Integer>> subs =
				findMethodSuggestions(classes, inv.name(), params, expected, loader);

		if (subs.isEmpty())
			return;

		else {
			Clazz.Method suggestion = subs.get(0).first();
			StringBuilder msg = new StringBuilder();
			msg.append(String.format("\nA possible substitute is %s.%s(",
				ClassLoader.pathChild(owner.toString()), suggestion.name()));

			for (int i = 0; i < suggestion.type().parameterTypes().size(); i++) {

				if (i != 0)
					msg.append(", ");

				Type t = suggestion.type().parameterTypes().get(i);

				msg.append((suggestion.isVariableArity() && i == suggestion.type().parameterTypes().size()-1) ?
						((Type.Array)t).element().toString() : t.toString());
			}

			if (suggestion.isVariableArity())
				msg.append("...");

			msg.append(")");

			suggestions.add(new Pair<String, Integer>(msg.toString(),subs.get(0).second()));
		}
	}

	/**
	 * Helper method that, given a class the found expression has as an attribute,
	 * combs that class looking for methods and fields that could be suggested to the user
	 *
	 * @param foundClass	- The class to search through
	 * @param found			- The found expression (invalid type)
	 * @param expected		- The expected expression type
	 * @param suggestions	- The list of suggestions so far
	 * @param loader		- The classloader
	 *
	 * @throws ClassNotFoundException
	 */
	private static void checkClassForSuggestions(Clazz foundClass, Expr found,
			Type expected, List<Pair<String, Integer>> suggestions,
			ClassLoader loader) throws ClassNotFoundException {

		TypeSystem types = new TypeSystem();

		//Check through methods, weighting on number of parameters
		for (Clazz.Method m : foundClass.methods()) {
			if (m.type().returnType() instanceof Type.Void || !types.boxSubtype(expected, m.type().returnType(), loader))
				continue;

			int weight = (m.isVariableArity()) ? m.parameters().size()-1 : m.parameters().size();
			String suggestion = String.format("\nA possible substitute is: (%s).%s(",
					found, m.name());

			for (int i = 0; i < m.type().parameterTypes().size(); i++) {
				if (i != 0)
					suggestion += (", ");
				Type t = m.type().parameterTypes().get(i);
				suggestion += (m.isVariableArity() && i == m.type().parameterTypes().size()-1) ?
						((Type.Array)t).element().toString() : t.toString();
			}

			if (m.isVariableArity())
				suggestion += "...";
			suggestion += ")";
			suggestions.add(new Pair<String, Integer>(suggestion, weight));
		}

		//Check through fields (minimum weighting)
		for (Clazz.Field f : foundClass.fields()) {
			if (!types.boxSubtype(expected, f.type(), loader))
				continue;
			suggestions.add(new Pair<String, Integer>(String.format(
					"\nA possible substitute is: (%s).%s", found, f.name()), 0));
		}
	}

	/**
	 * Given a FieldNotFoundException, uses the data stored in that
	 * exception to find a viable substitute field or method
	 * call for the target field. Uses that substitute to construct
	 * a more useful error message for the user than the default message.
	 *
	 * @param ex - The FieldNotFound exception encountered
	 */
	public static void handleFieldNotFound(FieldNotFoundException ex, SourceLocation loc) {

		Set<Clazz> classes = getClasses(ex.loader(), ex.owner());
		classes = getSuperClasses(ex.loader(), classes);

		Pair<List<Pair<Clazz.Field, Integer>>,
		 List<Pair<Clazz.Method, Integer>>> suggestions = findFieldSuggestions(classes, ex.field(), null, ex.loader());

		List<Pair<Clazz.Field, Integer>> fields = suggestions.first();
		List<Pair<Clazz.Method, Integer>> methods = suggestions.second();

		//Throw a Syntax Error with the appropriate error message

		String suggestion;

		if (fields.isEmpty()) {
			if (methods.isEmpty()) {
				suggestion = "";
			}
			else suggestion = String.format("\nA possible substitute is method %s.%s()", ClassLoader.pathChild(ex.owner().toString()),
					methods.get(0).first().name());
		}
		else if (methods.isEmpty()) {
			suggestion = String.format("\nA possible substitute is field %s.%s", ClassLoader.pathChild(ex.owner().toString()),
					fields.get(0).first().name());
		}
		else {
			suggestion = (fields.get(0).second() < methods.get(0).second()) ?
					String.format("\nA possible substitute is field %s.%s", ClassLoader.pathChild(ex.owner().toString()),
							fields.get(0).first().name()) :
					String.format("\nA possible substitute is method %s.%s()", ClassLoader.pathChild(ex.owner().toString()),
							methods.get(0).first().name());
		}

		throw new SyntaxError(String.format("Field %s.%s not found%s", ClassLoader.pathChild(ex.owner().toString()),
				ex.field(), suggestion), loc.line(), loc.column());
	}

	/**
	 * Helper method that returns a set of suggested fields and methods to replace a given field.
	 *
	 * @param classes	- The list of all classes to check
	 * @param field 	- The field we are substituting for
	 * @param expected	- the expected return type of the field (or null if unknown)
	 * @return
	 */
	private static Pair<List<Pair<Clazz.Field, Integer>>,
				 List<Pair<Clazz.Method, Integer>>> findFieldSuggestions
				 (Set<Clazz> classes, String field, Type expected,
						 ClassLoader loader) {

		//First, look for misspelled/substitute field names
		List<Pair<Clazz.Field, Integer>> fields = getFields(classes, field, expected, loader);

		//Then check for non-void methods with no parameters
		List<Pair<Clazz.Method, Integer>> methods = getFieldMethods(classes, field, expected, loader);

		//Finally, we sort the two lists and return them
		Collections.sort(fields, new WeightComparator<Pair<Clazz.Field, Integer>>());
		Collections.sort(methods, new WeightComparator<Pair<Clazz.Method, Integer>>());

		return new Pair<List<Pair<Clazz.Field, Integer>>,
				 List<Pair<Clazz.Method, Integer>>>(fields, methods);
	}

	/**
	 * Helper method that finds the list of available fields within a certain
	 * edit distance of the target field.
	 *
	 * @param classes	- The set of all classes to check fields of
	 * @param field		- The name of the target field
	 * @param expected	- The expected type of the target field (null if unknown)
	 * @param loader	- The classloader
	 * @return
	 */
	private static List<Pair<Clazz.Field, Integer>> getFields(
			Set<Clazz> classes, String field, Type expected,
			ClassLoader loader) {

		List<Pair<Clazz.Field, Integer>> fields = new ArrayList<Pair<Clazz.Field, Integer>>();
		TypeSystem types = new TypeSystem();

		for (Clazz c : classes) {
			for (Clazz.Field f : c.fields()) {
				try {
					if (expected != null && !types.boxSubtype(expected, f.type(), loader))
						continue;
					int dist = distance(field, f.name());
					if (dist <= MAX_DIFFERENCE)
						fields.add(new Pair<Clazz.Field, Integer>(f, dist));
				}
				catch (ClassNotFoundException e) {
					//Shouldn't happen. We continue without adding to suggestions
				}
			}
		}
		return fields;
	}

	/**
	 * Helper method that finds non-void methods that take no parameters
	 * as a possible substitute for a target field.
	 *
	 * @param classes	- The set of classes to check the methods of
	 * @param field		- The name of the target field
	 * @param expected	- The expected type of the field (null if unknown)
	 * @param loader	- The classloader
	 * @return
	 */
	private static List<Pair<Clazz.Method, Integer>> getFieldMethods(
			Set<Clazz> classes, String field, Type expected, ClassLoader loader) {

		List<Pair<Clazz.Method, Integer>> methods = new ArrayList<Pair<Clazz.Method, Integer>>();

		TypeSystem types = new TypeSystem();
		for (Clazz c : classes) {

			for (Clazz.Method m : c.methods()) {
				try {
					if (m.type().returnType() instanceof Type.Void || !m.parameters().isEmpty())
						continue;
					if (expected != null && !types.boxSubtype(expected, m.type().returnType(), loader))
						continue;

					int dist = distance(field, m.name()) + 2;
					if (dist <= MAX_DIFFERENCE)
						methods.add(new Pair<Clazz.Method, Integer>(m, dist));
				}
				catch (ClassNotFoundException e) {
					//Shouldn't happen. We continue without adding to suggestions
				}
			}
		}
		return methods;
	}

	/**
	 * Creates a more helpful package not found error message,
	 * by finding the directory containing the class with the bad package declaration,
	 * to suggest that directory as an alternative package name.
	 * Uses information stored in the initially thrown PackageNotFoundException to find the directory.
	 *
	 * @param ex	- The PackageNotFoundException initially thrown
	 */
	public static void handlePackageNotFound(PackageNotFoundException ex) {
		Clazz jilClass = ex.jilClass();
		String pkg = jilClass.type().pkg().replace('.', File.pathSeparatorChar);
		List<String> sourcepath = ex.sourcepath();
		List<String> classpath = ex.classpath();
		String result = null;

		//A pairing of directory to classpath parent directory (used to find relative path)
		Stack<Pair<String, String>> directories = new Stack<Pair<String, String>>();

		for (String dir : sourcepath) {
			if (!dir.contains("."))
				directories.push(new Pair<String, String>(dir, dir));
		}

		for (String dir : classpath) {
			if (!dir.contains(".") && ! directories.contains(new Pair<String, String>(dir, dir)))
				directories.push(new Pair<String, String>(dir, dir));
		}

		outer:
			while(!directories.isEmpty()) {
				Pair<String,String> dir = directories.pop();
				File f = new File(dir.first());

				if (!f.isDirectory())
					continue;

				for (String file : f.list()) {

					if (file.equals(jilClass.name() + ".java")) {
						result = dir.first().replaceAll(dir.second(), "").substring(1).replace(File.separatorChar, '.');
						break outer;
					}
					else if (!file.contains(".")) {

						//File is a directory, so can push it onto the stack
						directories.push(new Pair<String, String>(dir.first()+File.separator+file, dir.second()));
					}
				}
			}

		//Not sure if possible, but will handle the case anyway
		if (result == null)
			throw new SyntaxError("Unable to find source file directory", -1, -1);

		throw new SyntaxError(String.format("Unable to find package %s\nUse source directory package instead: %s",
				pkg, result), -1, -1);
	}

	/**
	 * This method takes the information stored in a MethodNotFoundException,
	 * and uses it to find the most viable substitute method for the user.
	 * It then uses that substitute to create a syntax error to display a more
	 * helpful error message to the user than the default exception message.
	 *
	 * @param ex	- The exception containing information required to find a substitute
	 * @param loc	- The location of the error
	 */
	public static void handleMethodNotFound(MethodNotFoundException ex, SourceLocation loc) {

		Set<Clazz> classes = getClasses(ex.loader(), ex.owner());
		classes = getSuperClasses(ex.loader(), classes);

		List<Pair<Clazz.Method, Integer>> suggestions = findMethodSuggestions(classes, ex.method(),
				ex.parameters(), null, ex.loader());

		//For now, we will only suggest the top level suggestion - that could change
		Clazz.Method suggestion = (suggestions.isEmpty()) ? null : suggestions.get(0).first();

		StringBuilder msg = new StringBuilder(100);
		msg.append(String.format("Method \"%s.%s(", ClassLoader.pathChild(ex.owner().toString()), ex.method()));
		boolean firstTime = true;
		for (Type t : ex.parameters()) {
			if (!firstTime)
				msg.append(", ");
			msg.append(t.toString());
			firstTime = false;
		}
		msg.append(")\" not found.");
		if (suggestion == null)
			throw new SyntaxError(msg.toString(), loc.line(), loc.column());

		msg.append(String.format("\nA possible substitute is \"%s.%s(",
				ClassLoader.pathChild(ex.owner().toString()), suggestion.name()));

		//Formatting must be double-checked for variable arity methods
		for (int i = 0; i < suggestion.type().parameterTypes().size(); i++) {
			if (i != 0)
				msg.append(", ");

			Type t = suggestion.type().parameterTypes().get(i);
			msg.append((suggestion.isVariableArity() && i == suggestion.type().parameterTypes().size()-1) ?
					((Type.Array)t).element().toString() : t.toString());
		}

		if (suggestion.isVariableArity())
			msg.append("...");
		throw new SyntaxError(msg.toString()+")\"", loc.line(), loc.column());
	}

	/**
	 * Helper method that returns a list of the possible substitutes/suggestions for a method,
	 * weighting the substitutes based on the number of edits to method name and parameters necessary
	 *
	 * @param classes		- The set of all classes to search
	 * @param method		- The name of the method you are looking for
	 * @param parameters	- The list of parameters of the method you are looking for
	 * @param expected		- The expected return type of the method (or null if unknown)
	 * @param loader		- The classloader
	 * @return
	 */
	private static List<Pair<Clazz.Method, Integer>> findMethodSuggestions
		(Set<Clazz> classes, String method, List<Type> parameters, Type expected,
				ClassLoader loader) {

		//First, look for all methods with a name in a certain edit range of the target
		Set<Pair<String, Integer>> names =  getMethodNames(classes, method, expected, loader);

		//Next, check for methods with a different number of parameters
		List<Pair<Clazz.Method, Integer>> methods = getMethodsByParams(names, classes, parameters);

		//Finally, check for different types of parameters between target and substitute methods
		List<Pair<Clazz.Method, Integer>> suggestions = getMethodsByParamTypes(methods, parameters, loader);

		Collections.sort(suggestions, new WeightComparator<Pair<Clazz.Method,Integer>>());
		return suggestions;
	}

	/**
	 * Helper method that returns a set of all accessible method names within
	 * a certain edit distance range of the target method name
	 *
	 * @param classes	- The set of classes to search
	 * @param method	- The name of the target method
	 * @param expected	- The expected return type of the method (or null if unknown)
	 * @param loader	- The classloader
	 * @return
	 */
	private static Set<Pair<String, Integer>> getMethodNames(Set<Clazz> classes,
			String method, Type expected, ClassLoader loader) {

		Set<Pair<String, Integer>> names = new HashSet<Pair<String, Integer>>();
		TypeSystem types = new TypeSystem();

		for (Clazz c : classes) {
			for (Clazz.Method m : c.methods()) {
				try {
					//We want to ignore constructors
					if (m.name().equals(c.name()))
						continue;
					if (expected != null && !types.boxSubtype(expected, m.type().returnType(), loader))
						continue;

					int dist = distance(method, m.name());
					if (dist <= MAX_DIFFERENCE)
						names.add(new Pair<String, Integer>(m.name(), dist));
				}
				catch (ClassNotFoundException e) {
					//Shouldn't happen. Continue without considering this method
				}
			}
		}
		return names;
	}

	/**
	 * Helper method that returns a list of all available methods similar to a target
	 * method, weighting choices by how close their number of parameters are to a target
	 * set of parameters (and by a method's existing weighting)
	 *
	 * @param names			- A set of method names to search through, and the weighting on each name
	 * @param classes 		- The set of classes these methods belong to
	 * @param params		- The list of parameter types used in the target method call
	 * @return
	 */
	private static List<Pair<Clazz.Method, Integer>> getMethodsByParams(
			Set<Pair<String, Integer>> names, Set<Clazz> classes, List<Type> params) {

		List<Pair<Clazz.Method, Integer>> methods = new ArrayList<Pair<Clazz.Method, Integer>>();

		for (Pair<String, Integer> p : names) {
			for(Clazz c : classes) {
				for (Clazz.Method m : c.methods(p.first())) {
					int diff;

					//The formula for weighting is different for methods with variable arity
					if (!m.isVariableArity())
						diff = Math.abs(m.parameters().size() - params.size());

					else
						diff = (m.parameters().size() <= (params.size()+1))
								? 0 : m.parameters().size() - (params.size()+1);

					if (diff + p.second() <= MAX_DIFFERENCE) methods.add(new Pair<Clazz.Method, Integer>(m, diff + p.second()));
				}
			}
		}
		return methods;
	}

	/**
	 * Helper method that further weights and sorts a set of possible substitute
	 * methods based on the difference between the supplied parameter types and
	 * the substitute's parameter types
	 *
	 * @param methods	- The list of substitute methods to check
	 * @param params	- The supplied (target) parameter types
	 * @param loader	- The classloader
	 * @return
	 */
	private static List<Pair<Clazz.Method, Integer>> getMethodsByParamTypes(
			List<Pair<Clazz.Method, Integer>> methods,
			List<Type> params, ClassLoader loader) {

		TypeSystem types = new TypeSystem();
		List<Pair<Clazz.Method, Integer>> suggestions = new ArrayList<Pair<Clazz.Method, Integer>>();

		for (Pair<Clazz.Method, Integer> p : methods) {
			try {

				List<Type> subParams = p.first().type().parameterTypes();
				boolean arity = p.first().isVariableArity();
				int weight = p.second();
				int min = Math.min(params.size(), subParams.size());

				//To account for variable arity array types, don't want to check final element
				if (arity && params.size() >= subParams.size())
					min--;

				for (int i = 0; i < min; i++) {
					if (!types.boxSubtype(params.get(i), subParams.get(i), loader))
					weight++;
				}

				//Need to check all types at end for varargs methods match final parameter type
				if (arity && params.size() >= subParams.size()) {
					for (int i = subParams.size()-1; i < params.size(); i++) {
						if (!types.boxSubtype(params.get(i),
								((Type.Array)subParams.get(subParams.size()-1)).element(), loader))
							weight++;
					}
				}

				if (weight <= MAX_DIFFERENCE)
					suggestions.add(new Pair<Clazz.Method, Integer>(p.first(), weight));
			}
			catch (ClassNotFoundException e) {
				//Shouldn't happen, but if it does we simply skip over the method
			}
		}

		return suggestions;
	}

	/**
	 * Computes the Damerau-Levenshtein distance between two strings
	 * (Edit distance where allowed edits are deletion, insertion,
	 *  modification, and swapping of adjacent letters)
	 *
	 * @param src	- source string
	 * @param trg	- target string
	 * @return		- The Damerau-Levenshtein distance between the two
	 */
	private static int distance(String src, String trg) {

		if (src.equals(trg)) return 0;
		if (src.length() == 0) return trg.length();
		if (trg.length() == 0) return src.length();

		//Distance is always at least the size difference between the strings
		//If this is greater than max allowed distance we can exit immediately
		int lowerBound = Math.abs(src.length() - trg.length());
		if (lowerBound > MAX_DIFFERENCE)
			return lowerBound;

		int[][] matrix = new int[src.length()+2][trg.length()+2];
		int inf = src.length() + trg.length();
		matrix[0][0] = inf;

		//Initialize the first few entries in the matrix

		for (int i = 0; i <= src.length(); i++) {
			matrix[i+1][1] = i;
			matrix[i+1][0] = inf;
		}

		for (int i = 0; i <= trg.length(); i++) {
			matrix[1][i+1] = i;
			matrix[0][i+1] = inf;
		}

		//Need to set up a mapping of characters to integers
		Map<Character, Integer> map = new HashMap<Character, Integer>();

		//Initialize the dictionary with the characters in the source and target words
		for (int i = 0; i < src.length(); i++) {
			char c = src.charAt(i);
			if (!map.containsKey(c))
				map.put(c, 0);
		}
		for (int i = 0; i < trg.length(); i++) {
			char c = trg.charAt(i);
			if (!map.containsKey(c))
				map.put(c, 0);
		}

		//Main loop for calculating the rows of the matrix
		//Once this has terminated, distance will be in matrix[src.length()+1][trg.length()+1]
		for (int i = 1; i <= src.length(); i++) {
			int DB = 0;
			for (int j = 1; j <= trg.length(); j++) {
				int i1 = map.get(trg.charAt(j-1));
				int j1 = DB;

				if (src.charAt(i-1) == trg.charAt(j-1)) {
					matrix[i+1][j+1] = matrix[i][j];
					DB = j;
				}
				else {
					matrix[i+1][j+1] = Math.min(matrix[i][j],
							Math.min(matrix[i+1][j], matrix[i][j+1])) + 1;
				}
				matrix[i+1][j+1] = Math.min(matrix[i+1][j+1], matrix[i1][j1] + (i-i1-1) + 1 + (j - j1 - 1));
			}
			map.put(src.charAt(i-1), i);
		}
		return matrix[src.length()+1][trg.length()+1];
	}

	/**
	 * Helper method that, when given a reference type, returns all the classes
	 * that can be substituted into that type
	 *
	 * @param loader - The ClassLoader required to load the classes
	 * @param owner  - The reference type we are checking
	 * @return
	 */
	private static Set<Clazz> getClasses(ClassLoader loader, Type.Reference owner) {
		Set<Clazz> classes = new HashSet<Clazz>();
		Stack<Type.Reference> stk = new Stack<Type.Reference>();
		stk.push(owner);

		while (!stk.isEmpty()) {
			Type.Reference ref = stk.pop();

			if (ref instanceof Type.Clazz)

				try {
					classes.add(loader.loadClass((Type.Clazz)ref));
				} catch (ClassNotFoundException e) {
					//Skip trying to load this class
					continue;
				}

			else if (ref instanceof Type.Intersection) {
				Type.Intersection it = (Type.Intersection) ref;
				for (Type.Reference b : it.bounds())
					stk.push(b);
			}

			else if (ref instanceof Type.Wildcard) {
				//Not sure what to do here, if anything
			}
		}
		return classes;
	}

	/**
	 * Helper method that, when given a set of classes, returns the corresponding
	 * set of all classes and super classes.
	 *
	 * @param loader - A ClassLoader (to read classes)
	 * @param classes - The set of classes we want to expand to include parent classes
	 * @return
	 */
	private static Set<Clazz> getSuperClasses(ClassLoader loader,
			Set<Clazz> classes) {

		Set<Clazz> result = new HashSet<Clazz>();
		for (Clazz c : classes) {
			try {
				Clazz tmp = c;
				while (tmp != null && !result.contains(tmp)) {
					result.add(tmp);
					if (c.superClass() == null)
						break;

					tmp = loader.loadClass(c.superClass());
				}
			} catch (ClassNotFoundException e) {
				//Skip trying to load this superclass
				continue;
			}
		}

		return result;
	}

	/**
	 * Private class used to sort substitutes by a given weighting
	 *
	 * @author Daniel Campbell
	 *
	 * @param <E> - A pair where the (Integer) weighting is stored in the second value of the pair
	 */
	private static class WeightComparator<E extends Pair<?, Integer>> implements Comparator<E> {

		public int compare(E o1, E o2) {
			return o1.second().compareTo(o2.second());
		}
	}
}
